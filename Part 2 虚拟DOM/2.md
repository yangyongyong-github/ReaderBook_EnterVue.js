
状态可以是任意类型，Obj Arr Str Number Boolean等
这些状态最终会以段落、表单、链接或者按钮等元素呈现在页面上。
我们将状态作为输入，并生成DOM输出到页面上显示出来，这个过程叫做渲染。
而程序运行的时候，状态会不断的发生改变（用户点击按钮，Ajax请求等异步操做）

【如何确定状态中发上了什么变化，以及需要在哪里更新DOM？】
要做到当状态发生变化时，只更新和这个DOM相关的DOM节点，是很困难的

目前问题的解决方案有一些：
ang总脏检查流程、react中虚拟DOM，vue中细粒度的绑定

虚拟DOM的解决方式是通过状态生成一个虚拟节点树，然后使用虚拟节点树进行渲染。
再渲染之前。会使用新生成的虚拟节点树和上次生成的虚拟节点数做比对，只渲染不同的部分。


## 5.2 为什么引入虚拟DOM

事实上 ang和react变化侦测有一个共同的特点，不知道哪些状态变了，因此只能暴力的比对。

vue的变化侦听却不一样，它在一定程度上指导具体哪些状态方式发生了变化，通过更细粒度的绑定来更新视图。已经知道哪些变了，无需进行比对，vue1.0
代价：粒度太细了，每一个绑定都有一个对应的watcher来观察状态的变化，占据一定的内存开胸啊和一些依赖追踪的开销。
当状态被多个节点使用的时候，开销就越大。（大项目照此开销巨大）

vue2.0粒度划分渲染了中等，且引入了虚拟DOM。
组件级别是一个watcher实例（其内部不管哪个状态的改变都会引发重新渲染），比较折中的方案

## 5.3 vue中的虚拟DOM
我们使用模板来描述状态与DOM之间的映射关系。vue通过编译将模板转换为渲染函数render，执行其可以得到一个虚拟节点树，使用其可以渲染界面

虚拟DOM的最终目标是将虚拟节点（vnode）渲染到视图上。
由于DOM操做比较慢，所以这些DOM操做在性能上会有一定的浪费，避免这些不必要的DOM操做会提升很大一部分的性能。

使用diff算法将vnode与OldVnode进行比对

可以看出，虚拟DOM再vue中所作的事情并没有想象中那么复杂，主要做：
-  提供与真实DOM节点对应的虚拟节点vnode
-  将虚拟节点vnode和旧虚拟节oldVnode进行比对，然后找出差异部分，进行更新。

vnode是JS中普通的一个对象，其属性上保存了生成DODM节点苏需要的一些数据。

diff - patch算法 可以判断出哪些节点发生了变化，


总结：
虚拟DOM：原理是使用状态生成虚拟节点，然后使用虚拟节点渲染视图。

# Unit 6  VNode
## 5.1 VNode
vue中的VNode类，使用它可以实例化不同类型的vnode实例，而不同类型的vnode实例各自表示不同类型的DOM元素。

元素节点、文本节点、注释节点等

VNode.js

# 6.2 VNode的作用

由于每次渲染view时，先创建vnode，然后使用它创建真实的DOM插入到页面中
所以可以将上一次渲染视图的vnode缓存起来，之后每当需要重新渲染视图时，与新创建的vnode进行比对，找出差异点，据此去修改对应的DOM。










